---
title: "리눅스 파일 복사"
date: 2025-11-14
tags:
  - "ChatGPT"
url: "https://chatgpt.com/c/691688ea-fefc-8324-85a2-caf19e7a9f58"
projectName: ""
---

## You

복사 리눅스 커맨들 알려줘..

---

## ChatGPT

리눅스에서 **파일/디렉터리 복사**에 사용하는 기본 커맨드는 아래와 같아!

---

## ✅ 1. 파일 복사 (copy file)
```
cp source.txt dest.txt
```

- `source.txt` → `dest.txt`로 복사

---

## ✅ 2. 디렉터리 복사 (폴더 통째로)
```
cp -r source_dir/ dest_dir/
```

- `-r` 또는 `-R` : 재귀(recursive), 내부 폴더까지 포함

---

## ✅ 3. 복사하면서 진행 과정 보기
```
cp -v source.txt dest.txt
cp -rv source_dir/ dest_dir/
```

`-v` : verbose(무슨 파일 복사했는지 출력)

---

## ✅ 4. 덮어쓰기 물어보지 않고 강제 복사
```
cp -f source.txt dest.txt
```
`-f` : force

---

## ✅ 5. 파일 여러 개를 한 번에 복사
```
cp file1.txt file2.txt file3.txt target_dir/
```

---

## ✅ 6. 특정 패턴으로 복사 (예: *.txt)
```
cp *.txt target_dir/
```

---

## ✅ 7. 속성까지 그대로 유지하며 복사 (타임스탬프, 권한 등)
```
cp -a source_dir/ dest_dir/
```

`-a` : archive mode (거의 완벽한 복사)

---

필요한 예시 있으면 상황 알려줘.  
예: “폴더 전체를 다른 파티션으로 백업하고 싶어”, “숨김파일 포함해서 복사하고 싶어” 등.

---

## You

B030240@V124-UB20-B030240:~/work1/ttl-pre-release/build-axon/linux_yp4.0_cgw_1.0.0_pre/poky$ git branch
* (no branch)

이건 어떤 상태인거야?

---

## ChatGPT

`git branch` 했을 때 **`* (no branch)`** 로 보이면, 지금 **브랜치에 속해 있지 않은 상태**, 즉 **detached HEAD 상태**라는 뜻이야.

---

# ✅ Detached HEAD란?

현재 checkout 한 위치가 **브랜치 이름이 아니라 특정 커밋(commit)** 이라는 의미.

즉,
- 브랜치의 HEAD를 따라다니는 게 아니라
- **특정 커밋을 직접 가리키는 상태**  

이 상태에서는 변경을 해도 브랜치에 기록되지 않고,  
새 커밋을 만들어도 **브랜치로 이어지지 않음** → 나중에 잃어버릴 수 있음.

---

# 왜 이런 상태가 됐을까?

일반적으로 아래 같은 경우에 생김:

### ✔ 특정 커밋으로 checkout 한 경우
```
git checkout a1b2c3d4
```

### ✔ 태그(tag)로 checkout 한 경우 (브랜치로 만들지 않고)
```
git checkout v1.0.0
```

### ✔ repo sync 후 manifest에 checkout 이 commit SHA 로 박혀 있을 때

Telechips repo 환경에서 자주 나오는 형태야.

---

# 어떻게 브랜치로 돌아가?

지금 원래 브랜치를 알면:
```
git checkout <branch-name>
```

예:  
```
git checkout master
git checkout dev
git checkout release/1.0.0-pre
```

---

# detached HEAD 상태에서 브랜치를 만들고 싶으면?

지금 checkout 되어있는 commit을 기준으로 새로운 브랜치를 만들고 싶으면:

```
git checkout -b my-new-branch
```

---

필요하면  
- “repo sync 했는데 왜 detached HEAD인지”  
- “manifest에서 어떤 값 때문에 이런지”  
도 같이 확인해 줄게.

---

## You

B030240@V124-UB20-B030240:~/work1/ttl-pre-release/build-axon/linux_yp4.0_cgw_1.0.0_pre/poky$ git branch -r
  m/dev -> release_1.0.0-pre
  origin/SD710XL-1670-standalone-demo
  origin/SD710XL-1725-yocto-build-source-mirror-down
  origin/dev
  origin/feature/SD710XL-1662-cmr-250910
  origin/feature/SD710XL-1662-cmr-251022
  origin/master
  origin/qa/SD710XL-1751-linux_yp4.0_cgw_1.0.0
  origin/release/1.0.0-pre

에서 특정 브랜치로 이동해서 작업하고 싶다면?

---

## ChatGPT

지금 remote 브랜치 목록이 보이고 있으니까,  
**원하는 원격 브랜치를 로컬에 생성한 뒤 checkout** 하면 돼.

---

# ✅ 특정 원격 브랜치로 이동(작업)하는 가장 일반적인 방법

예를 들어 `origin/release/1.0.0-pre` 브랜치로 작업하고 싶으면:

```
git checkout -b release/1.0.0-pre origin/release/1.0.0-pre
```

이 명령은  
- 로컬에 `release/1.0.0-pre`라는 새 브랜치 생성  
- 그리고 그 브랜치가 `origin/release/1.0.0-pre`를 추적하도록 설정  

---

# 🔥 만약 이미 동일 이름의 브랜치가 로컬에 있으면?

```
git checkout release/1.0.0-pre
git pull
```

---

# ✔ 참고: remote alias `m/dev -> release_1.0.0-pre`가 의미하는 것

```
m/dev -> release_1.0.0-pre
```

이건 **remote tracking reference**이고,  
manifest에서 `m/dev`가 사실상 `release_1.0.0-pre` 커밋을 가리키고 있다는 뜻이야.  
repo 환경에서 종종 나오는 형태.

---

# ✨ 추천하는 작업 방식

📌 **release/1.0.0-pre에서 작업하고 싶다 → 아래처럼 하면 됨**

```
git checkout -b mywork origin/release/1.0.0-pre
```

또는 그냥 그 브랜치 이름 그대로 쓰고 싶으면:

```
git checkout -b release/1.0.0-pre origin/release/1.0.0-pre
```

---

원하는 브랜치 이름 알려주면 정확하게 커맨드 만들어줄게.

---

## You

git checkout -b 가 의미하는것이 뭐야?

---

## ChatGPT

`git checkout -b` 는 **새로운 로컬 브랜치를 만들고 그 브랜치로 바로 이동(checkout)한다**는 뜻이야.

아주 자주 쓰이는 Git 명령이야.

---

# ✅ git checkout -b <새브랜치명> <기준점>

형식은 다음과 같아:

```
git checkout -b <new-branch-name> <start-point>
```

- `<new-branch-name>` : 만들고 싶은 로컬 브랜치 이름
- `<start-point>` : 어떤 커밋/브랜치/태그에서 브랜치를 만들지 (생략 가능)

---

# 📌 의미를 자세히 풀어보면:

## 1) **새 브랜치 생성**
```
git branch <new-branch-name> <start-point>
```
이 동작과 같은데,

## 2) **그 브랜치로 바로 이동**
```
git checkout <new-branch-name>
```

위 두 가지 단계가 합쳐져 있는 명령이 바로:

```
git checkout -b <브랜치명> <start-point>
```

---

# 🔥 예시

### ▷ 원격 브랜치에서 로컬 브랜치를 만들 때
```
git checkout -b release/1.0.0-pre origin/release/1.0.0-pre
```

👉 `origin/release/1.0.0-pre` 커밋을 기준으로  
👉 로컬 브랜치 `release/1.0.0-pre`를 만들고  
👉 바로 그 브랜치로 이동

---

# 만약 <start-point> 생략하면?
```
git checkout -b feature/test
```

이 경우는 **현재 HEAD 상태(지금 보고 있는 커밋)** 기준으로 새로운 브랜치 생성.

---

필요하면  
- 어떤 상황에서 `-b`를 쓰는 게 맞는지  
- 현재 repo/yocto 구조에서 어떻게 쓰는 게 최선인지  
도 같이 설명해줄게.

---

## You

/lib/systemd/network/80-eth0.network

#DHCP Setting
#[Match]
#Name=eth*
#KernelCommandLine=!nfsroot

#[Network]
#DHCP=yes

#[DHCP]
#RouteMetric=10
#ClientIdentifier=mac

#Static Setting
[Match]
Name=eth*

[Link]
MACAddress=F4:50:EB:01:02:03
MTUBytes=1500

[Network]
Address=192.168.137.2/24
Gateway=192.168.137.1

인데.. 이걸 DHCP는 쓰고.. MAC address를 고정하고 싶다면?

---

## ChatGPT

DHCP를 사용하면서도 **MAC Address(= Link MACAddress)** 를 **고정**하고 싶다면, 설정은 이렇게 하면 돼.

systemd-networkd에서는 **DHCP를 켜고**,  
`[Link]` 섹션에서 **고정 MACAddress** 를 설정하면 동시에 사용 가능해.

---

# ✅ 예시 설정 (DHCP + 고정 MAC)

```
[Match]
Name=eth*

[Link]
MACAddress=F4:50:EB:01:02:03
MTUBytes=1500

[Network]
DHCP=yes

[DHCP]
RouteMetric=10
ClientIdentifier=mac
```

---

# 📌 동작 방식 설명

### ✔ DHCP는 IP를 자동으로 받음
- `[Network]`에서 `DHCP=yes` 를 선언했기 때문에  
  IP, Gateway, DNS 등은 DHCP 서버가 제공함.

### ✔ MAC Address는 networkd가 인터페이스 초기화할 때 강제로 적용
- `[Link]` 섹션의 `MACAddress=`가 있으면  
  인터페이스 업(UP) 시 이 MAC을 사용하도록 강제로 설정됨.

### ✔ `ClientIdentifier=mac`
- DHCP 요청 시 MAC 주소 기반으로 Client ID를 보냄 → 대부분의 DHCP 서버에서 고정 IP 배정 가능.

---

# ❗ 주의 사항

1. **이미 커널에서 MAC이 고정된 경우**  
   systemd-networkd가 바꾸지 못할 때도 있음 → 이 경우 udev 규칙 필요.

2. **u-boot에서 MAC이 설정되어 들어오는 경우**  
   systemd-networkd가 그대로 적용하거나 override 할 수 있음.

원하면  
- udev 방식으로 MAC을 강제하는 방법  
- 여러 NIC(eth0/eth1)에서 각각 고정 MAC+DHCP 적용  
도 만들어줄게.

---

## You

Name=eth0
KernelCommandLine=!nfsroot

에서.. eth*로 한 이유는?? 모든 것을 static으로??

KernelCommandLine=!nfsroot

이걸 지운 이유는??

---

## ChatGPT

아래 설정을 보면 원래는 DHCP 설정이면서 이렇게 되어 있었지?

```
[Match]
Name=eth*
KernelCommandLine=!nfsroot
```

여기서 **왜 eth\*** 를 쓰는지, **왜 KernelCommandLine=!nfsroot 를 지웠는지** 각각 설명해줄게.

---

# ✅ 1) Name=eth\* 를 사용하는 이유

### ✔ **여러 개의 Ethernet 인터페이스를 모두 매칭시키기 위해**
`eth*` 는 `eth0`, `eth1`, `eth2` … 모든 유사한 이름의 인터페이스를 의미해.

즉:

- `eth0`
- `eth1`
- `eth2`
- …

등 **여러 NIC가 있을 때 동일한 네트워크 설정을 적용하려고 한 것.**

그래서 DHCP를 쓴다면 모든 eth 인터페이스에 동작하도록 한 거고,  
Static 설정도 동일하게 모든 eth 인터페이스에 적용되는 구조였어.

---

# 📝 현재 설정에서는 왜 Name=eth0 로 바꿨을까?

지금 사용자 설정은 다음처럼 되어 있었지?

```
[Match]
Name=eth*
```

→ Static IP도 모든 eth 인터페이스에 적용됨.

**그러면 eth1, eth2 같은 다른 포트도 모두 같은 설정을 가져가게 되어 충돌**해야 해.  
그래서 static 환경에서는 보통 다음처럼 명확히 지정해야 해:

```
Name=eth0
```

---

# ✅ 2) KernelCommandLine=!nfsroot 를 쓰는 이유 (원래)

이 조건은:

```
KernelCommandLine=!nfsroot
```

을 의미하는데,

### ✔ 뜻: **커널 커맨드라인에 "nfsroot" 라는 단어가 있을 경우 이 network 설정을 적용하지 마라**

즉, 다음과 같은 커널 파라미터가 있을 때:

```
nfsroot=<서버ip>:/nfs/path
```

→ network 설정이 **자동 NFS root mount 목적**일 때는  
systemd-networkd가 네트워크 설정을 **따로 건드리지 않도록 조건을 걸어둔 것**이다.

**NFS root 부팅 시 네트워크 설정을 networkd가 재설정해버리면 시스템이 부팅 불능이 되기 때문!**

---

# ❗ 그럼 왜 이걸 제거했나?

지금 static 설정을 다음처럼 바꿨지:

```
[Match]
Name=eth*
```

그런데 현재 환경이 **NFS root가 아니거나**,  
혹은 **이 장치에서는 NFS root를 사용하지 않기 때문에 불필요한 조건**이라서 삭제한 것.

또는 더 단순하게 말하면:

- NFS root 환경이 아니기 때문에 조건이 의미 없음  
- DHCP/static 설정이 항상 적용되어도 문제가 없는 환경임

그래서 조건을 제거한 것.

---

# 📌 요약

| 항목 | 이유 |
|------|------|
| `Name=eth*` | 모든 eth 인터페이스에 동일한 네트워크 정책 적용하려고 사용한 것 (DHCP 환경에서 흔함) |
| `KernelCommandLine=!nfsroot` | 커널 파라미터에 nfsroot가 있을 때는 네트워크 설정을 적용하지 않도록 하는 안전장치 |
| 조건 제거한 이유 | 현재 시스템이 NFS root 방식으로 부팅하지 않거나, 이 조건이 더 이상 필요 없기 때문 |

---

필요하면  
- eth0만 static, 나머지는 DHCP  
- eth0 static + eth1 DHCP 동시에 적용  
같은 복합 설정 파일도 만들어줄게.

---

## You

내 피씨랑 연결했어.. 그럼 IP를 받게 하려면 어떻게 해야 하지?

---

## ChatGPT

지금 장비(보드)를 **PC와 직접 연결했을 때 DHCP로 IP를 받고 싶다**는 의미지?

그럼 핵심은 **PC 쪽에 DHCP 서버가 있어야 한다**는 거야.  
보드가 “IP를 받는다” = 보드가 DHCP **Client** → PC는 DHCP **Server** 역할 필요.

즉:

### 📌 보드 → DHCP Client (IP 받아야 함)  
### 📌 PC → DHCP Server (IP를 줘야 함)

---

# ✅ 1) 보드 쪽 설정 (systemd-networkd)

보드 쪽은 이렇게 하면 DHCP로 IP를 받음:

```
[Match]
Name=eth0

[Link]
MACAddress=F4:50:EB:01:02:03

[Network]
DHCP=yes

[DHCP]
ClientIdentifier=mac
```

※ 이 설정으로 보드는 **DHCP Client 모드**야.

---

# ✅ 2) PC 쪽에서 DHCP 서버를 켜야 함

PC가 어떤 OS냐에 따라 달라.

---

# 🔵 Windows 10/11에서 보드와 직접 연결 시 IP를 받게 하려면?

윈도우는 기본적으로 DHCP 서버 기능이 없음.  
하지만 **모바일 핫스팟**, **ICS(Internet Connection Sharing)** 를 켜면  
윈도우가 DHCP 서버 역할을 함.

---

## ✔️ 방법 A: 모바일 핫스팟 켜기 (가장 쉬움)

1. **설정 → 네트워크 및 인터넷 → 모바일 핫스팟**
2. “다른 장치에 내 인터넷 연결 공유” **ON**
3. 공유하는 네트워크 인터페이스를 **Ethernet** 으로 선택

이렇게 하면 **Windows가 자동으로 DHCP 서버 역할**을 해서  
보드에게 IP를 배정해 줌.

보드는 예를 들어:

```
192.168.137.2
```

이런 식으로 IP를 받게 됨.

---

## ✔️ 방법 B: ICS(인터넷 연결 공유) 켜기

1. **네트워크 어댑터** 창 열기
2. 인터넷이 연결된 어댑터 우클릭 → 속성
3. “공유(Sharing)” 탭
4. “다른 네트워크 사용자들이 … 연결할 수 있도록 허용” 체크
5. 공유 대상 인터페이스로 **보드가 연결된 Ethernet 인터페이스 선택**

Windows가 DHCP 서버 역할을 함.

---

# 🔵 Linux PC → 보드 연결 시 DHCP 주고 싶다면?

Linux PC에 DHCP 서버를 설치:

```
sudo apt install isc-dhcp-server
```

설정 파일 수정:

`/etc/dhcp/dhcpd.conf`

```
subnet 192.168.10.0 netmask 255.255.255.0 {
    range 192.168.10.100 192.168.10.200;
    option routers 192.168.10.1;
    option subnet-mask 255.255.255.0;
}
```

인터페이스 지정:

`/etc/default/isc-dhcp-server`

```
INTERFACESv4="eth0"
```

DHCP 서버 시작:

```
sudo systemctl restart isc-dhcp-server
```

그럼 보드가 자동으로 IP 받음.

---

# 🔥 결론 정리

### ❗ 보드에 DHCP=yes 해놔도  
➡️ PC가 DHCP 서버 역할을 안 하면 IP 못 받음.

### 즉, IP를 받게 하려면:
- Windows → 모바일 핫스팟 또는 ICS 켜기  
- Linux → DHCP 서버 직접 설치  

---

보드가 어떤 환경인지 알려주면 **가장 쉬운 방법으로 정확하게 셋업**해줄게!

---

## You

192.168.137.1 인 NIC에 연결했는데.. 
192.168.0.23 이라는 아이피를 할당 받았어..

---

## ChatGPT

보드가 **192.168.137.1** NIC(= 윈도우 기본 공유 네트워크 대역) 에 연결돼 있는데  
IP를 **192.168.0.23** 으로 받았다는 건…  

➡️ **그 NIC 뒤쪽에 또 다른 DHCP 서버가 있다는 뜻**이야.  
즉, 네 PC(192.168.137.1)가 DHCP를 주는 게 아니라  
다른 장비가 DHCP를 주고 있음.

---

# 🔥 왜 이런 현상이 생기나?

### ✔ Windows의 192.168.137.1 은 **ICS(인터넷 공유)** 또는 **핫스팟**일 때만 DHCP 서버 역할을 함.  
평소에는 DHCP 서버가 아님.

즉,

- 보드를 PC에 연결했다고 해서 자동으로 DHCP 서버가 생기지 않아.
- 그 결과 보드는 **다른 DHCP 서버**를 찾아서 IP를 받아버린 것.

예를 들어:
- 회사 공유기  
- 회사 스위치  
- 건너 연결된 라우터  
- Wi-Fi 브리지  
- USB 랜 어댑터에 연결된 대역  

이런 애들이 192.168.0.x 대역 DHCP를 제공한 것.

---

# 🔍 상황 쉽게 테스트해보는 방법

PC NIC 상태에서:
```
ipconfig /all
```

보드 연결된 NIC에 아래 값이 있으면 DHCP 서버는 Windows임:

```
IPv4 주소: 192.168.137.1
DHCP 사용: Yes
```

하지만 DHCP 서버 항목이 없다면:

➡ **Windows는 DHCP 서버가 아님 → IP는 외부 DHCP 서버에서 받은 것**

---

# ✔ 보드를 192.168.137.x 대역으로 DHCP 받게 만들려면?

## 🔵 방법 1: Windows ‘모바일 핫스팟’ 켜기

1. 설정 → 네트워크 및 인터넷 → 모바일 핫스팟
2. **ON**
3. "이더넷" 인터페이스 사용 지정

→ Windows가 자동으로 DHCP 서버 역할  
→ 보드는 **항상 192.168.137.X** 대역으로 IP를 받게 됨

---

## 🔵 방법 2: ICS(인터넷 연결 공유) 활성화

1. “네트워크 어댑터” 들어가서  
2. 인터넷이 있는 네트워크 → 속성  
3. 공유(Sharing) 탭  
4. “다른 사용자가 이 연결을…” 체크  
5. 공유 대상 NIC = 보드가 연결된 NIC 선택

➡ Windows DHCP 서버가 활성화됨  
➡ 보드: **192.168.137.x** 대역으로 IP 할당

---

# 🔍 결론

지금 보드가 **192.168.0.23** 을 받은 이유:

- PC는 DHCP 서버가 아니었고  
- 다른 네트워크 장비가 DHCP를 제공했고  
- 보드가 그 DHCP 요청에 응답한 것.

**원하는 대역(192.168.137.x)으로 받게 하려면 PC에서 DHCP 서버 기능을 반드시 켜야 함.**

---

원하면  
- 네 상황을 보고 딱 맞는 설정 확인해줄게  
- 네트워크 흐름도 그려서 설명할 수도 있음